### 문제 및 해설 파일 (Exam Questions & Solutions)  
**작성일**: 2025-02-24  
**담당자**: 이동인  

=========================================  

### 문제 1. 자료구조를 왜 사용할까요?  

**정답** 데이터를 효율적으로 저장하고 관리하여 연산을 빠르게 수행하기 위해 사용합니다.  

**해설**  
자료구조는 데이터를 구조적으로 저장하고 관리하여 연산을 효율적으로 수행할 수 있도록 도와줍니다.  
예를 들어, 배열(Array)은 빠른 인덱스 접근이 가능하고, 연결 리스트(Linked List)는 삽입/삭제가 빠릅니다.  
적절한 자료구조를 선택하면 알고리즘의 성능을 최적화할 수 있습니다.  

-----------------------------------------  

### 문제 2. 시간복잡도는 무엇일까요?  

**정답** 시간복잡도 : 어떤 알고리즘이 실행될 때 입력 크기에 비교했을 때 걸리는 시간  

**해설**  
시간복잡도(Time Complexity)는 입력 크기(n)가 증가할 때, 알고리즘의 실행 시간이 증가하는 패턴을 나타냅니다.  
빅-오 표기법(Big-O Notation)을 사용하여 분석하며, 예를 들어 정렬 알고리즘인 **퀵 정렬(Quick Sort)**의 평균 시간복잡도는 `O(n log n)`,  
버블 정렬(Bubble Sort)의 시간복잡도는 `O(n^2)`입니다.  

-----------------------------------------  

### 문제 3. 정적 배열과 동적 배열의 차이점은 무엇인가요?  

**정답**  
- **정적 배열**: 크기가 고정되어 있으며, 선언 시 크기를 지정해야 함.  
- **동적 배열**: 크기를 변경할 수 있으며, 필요에 따라 메모리를 할당하거나 해제할 수 있음.  

**해설**  
정적 배열(Static Array)은 **컴파일 타임에 크기가 결정되며**, 메모리 공간이 연속적으로 할당됩니다.  
동적 배열(Dynamic Array)은 **실행 시간(Runtime)에 크기를 변경할 수 있으며**, 필요에 따라 새로운 메모리를 할당하여 데이터를 확장할 수 있습니다.  
예를 들어, C++의 `std::vector`나 Java의 `ArrayList`는 내부적으로 동적 배열을 사용합니다.  

-----------------------------------------  

### 문제 4. 연결 리스트(Linked List)의 종류에는 어떤 것들이 있나요?  

**정답**  
1. **단일 연결 리스트 (Singly Linked List)**: 한 방향(다음 노드)으로만 연결된 리스트.  
2. **이중 연결 리스트 (Doubly Linked List)**: 양방향(이전 및 다음 노드)으로 연결된 리스트.  
3. **원형 연결 리스트 (Circular Linked List)**: 마지막 노드가 첫 번째 노드를 가리키는 리스트.  

**해설**  
연결 리스트는 동적으로 크기를 조정할 수 있는 자료구조입니다.  
- **단일 연결 리스트**는 한 방향으로만 접근 가능하여 `prev` 포인터가 필요하지 않습니다.  
- **이중 연결 리스트**는 양방향 접근이 가능하여 삽입/삭제가 더 효율적입니다.  
- **원형 연결 리스트**는 끝과 처음이 연결되어 있어 **순환적인 데이터 구조**에서 유용합니다.  

-----------------------------------------  

### 문제 5. 연결 리스트의 장점과 단점은 무엇인가요?  

**정답**  
- **장점**: 삽입/삭제가 빠름(`O(1)`, 포인터 변경만 필요), 크기 제한 없음.  
- **단점**: 임의 접근이 느림(`O(n)`, 순차 탐색 필요), 추가적인 메모리 사용(포인터 저장 공간 필요).  

**해설**  
연결 리스트는 데이터를 동적으로 저장할 수 있어 메모리 사용이 유연합니다.  
하지만 배열과 달리 **임의 접근이 불가능**하여 특정 위치의 데이터를 찾으려면 `O(n)` 시간이 필요합니다.  
또한 각 노드가 포인터를 포함하므로 **추가적인 메모리 오버헤드**가 발생합니다.  

-----------------------------------------  

### 문제 6. 스택(Stack)과 큐(Queue)의 차이점은 무엇인가요?  

**정답**  
- **스택(Stack)**: **LIFO (Last In, First Out)** 구조, 가장 마지막에 추가된 요소가 먼저 제거됨.  
- **큐(Queue)**: **FIFO (First In, First Out)** 구조, 먼저 들어온 요소가 먼저 제거됨.  

**해설**  
- 스택(Stack)은 `push()` 연산으로 데이터를 추가하고, `pop()` 연산으로 마지막에 추가된 요소를 제거합니다.  
- 큐(Queue)는 `enqueue()` 연산으로 데이터를 추가하고, `dequeue()` 연산으로 가장 먼저 추가된 요소를 제거합니다.  
- 예를 들어, **재귀 함수의 호출 스택**은 스택을 이용하고, **프린터 작업 대기열**은 큐를 이용합니다.  

-----------------------------------------  

### 문제 7. 다음 자료구조의 시간복잡도를 작성하세요.  
- 배열(Array)의 조회 (인덱스 접근)
- 배열(Array)의 삽입/삭제 (중간 위치에서) → `O(n)`  
- 연결 리스트(Linked List)의 삽입/삭제 (노드가 주어진 경우) → `O(1)`  
- 연결 리스트(Linked List)의 조회 (임의 위치 탐색) → `O(n)`  
- 스택(Stack)과 큐(Queue)의 삽입/삭제 → `O(1)`  

**정답**  
- **배열(Array)의 조회 (인덱스 접근)** → `O(1)`  
- **배열(Array)의 삽입/삭제 (중간 위치에서)** → `O(n)`  
- **연결 리스트(Linked List)의 삽입/삭제 (노드가 주어진 경우)** → `O(1)`  
- **연결 리스트(Linked List)의 조회 (임의 위치 탐색)** → `O(n)`  
- **스택(Stack)과 큐(Queue)의 삽입/삭제** → `O(1)`  

**해설**  
- 배열은 연속된 메모리를 사용하므로 **임의 조회(Random Access)**가 `O(1)`로 빠릅니다.  
- 하지만 중간에 데이터를 삽입/삭제할 경우, 모든 요소를 이동해야 하므로 `O(n)`이 걸립니다.  
- 연결 리스트는 **중간 삽입/삭제는 빠르지만** 특정 위치를 찾으려면 순차 탐색이 필요하여 `O(n)`이 걸립니다.  
- 스택과 큐의 삽입/삭제는 끝에서만 발생하므로 `O(1)`로 빠릅니다.  

-----------------------------------------  

### 문제 8. 동적 할당이란 무엇인가요?  

**정답** 실행 시간(runtime) 중에 메모리를 할당하는 방식으로, `new`, `malloc()` 등을 사용하여 동적으로 메모리를 할당하고, 사용이 끝나면 `delete`, `free()` 등을 사용하여 해제해야 한다.  

**해설**  
- **정적 메모리 할당**은 프로그램 실행 전에 크기가 정해지며, 스택(Stack) 영역에서 관리됩니다.  
- **동적 메모리 할당**은 실행 중에 크기를 변경할 수 있으며, 힙(Heap) 영역에서 관리됩니다.  
- 예를 들어, C++에서는 `int* arr = new int[10];`과 같이 배열을 동적으로 생성할 수 있습니다.  
- 사용이 끝나면 반드시 `delete[] arr;` 또는 `free(arr);`로 메모리를 해제해야 **메모리 누수(Memory Leak)**를 방지할 수 있습니다.  

