# 문제 파일 (Exam Questions)
# 작성일: 2025-02-21
# 담당자: 박설진

=========================================

문제 1. 데이터베이스 정규화란 무엇인가? (주관식)

-----------------------------------------

문제 2. 다음은 무엇에 대한 설명인가? (단답형)
데이터베이스의 중복 된 레코드 중 일부만 변경되어 모순되는 데이터가 발생하는 현상

-----------------------------------------

문제 3. 함수적 종속성 (Functional Dependency)에 대해서 완전함수종속, 부분함수종속의 개념을 넣어 설명해 보시오 (주관식)

-----------------------------------------

문제 4. 다음 중 **제1정규형(1NF)**을 만족하지 않는 테이블은 무엇인가?

A. 모든 컬럼의 값이 원자적이며, 하나의 값만을 가진다.
B. 테이블에서 모든 값이 하나의 데이터 타입을 따른다.
C. 컬럼에 중복된 값이 존재하지 않는다.
D. 테이블에서 각 행은 유일하게 식별될 수 있다.
E. 특정 컬럼에 배열 형태의 값이 저장되어 있다.

-----------------------------------------

문제 5. 다음 중 **제2정규형(2NF)**에 대한 설명으로 옳지 않은 것은 무엇인가?

A. 제2정규형은 제1정규형을 만족해야 한다.
B. 모든 비기본키 속성은 기본키에 대해 완전 함수 종속이어야 한다.
C. 기본키의 일부에만 의존하는 속성은 제거되어야 한다.
D. 제2정규형에서는 모든 속성이 기본키에 대해 부분 함수 종속되어야 한다.
E. 제2정규형은 데이터 중복을 최소화하기 위해 비기본키 속성들의 의존성을 정리한다.

-----------------------------------------

문제 6. 다음 중 **제3정규형(3NF)**을 만족하는 테이블의 특성으로 옳은 것은 무엇인가?

A. 기본키에 대한 부분 함수 종속이 존재할 수 있다.
B. 기본키에 의존하지 않는 비기본키 속성이 다른 비기본키 속성에 의존하는 것이 허용된다.
C. 기본키에 대한 완전 함수 종속만 존재한다.
D. 기본키 외의 속성이 다른 비기본키 속성에 의존하지 않아야 한다.
E. 제3정규형에서는 테이블을 분해하여 데이터 중복을 최소화한다.

-----------------------------------------

문제 7. 다음 중 **보이스 코드 정규형(BCNF)**에 대한 설명으로 옳지 않은 것은 무엇인가?

A. BCNF는 제3정규형(3NF)을 강화한 형태이다.
B. 테이블의 모든 함수 종속에서 종속되는 속성은 반드시 외래키여야 한다.
C. BCNF에서는 모든 속성이 기본키에만 의존해야 한다.
D. 기본키 외의 속성에 의존하는 비기본키 속성은 허용되지 않는다.
E. BCNF는 데이터 중복을 제거하고 데이터 일관성을 유지하는 데 도움이 된다.

-----------------------------------------

문제 8. 정규화의 주요 목표로 가장 적절한 것은 무엇인가?

A. 데이터의 무결성을 높이고, 중복을 최소화하며, 데이터베이스의 성능을 향상시키는 것이다.
B. 모든 데이터를 하나의 테이블에 저장하여 처리 속도를 높이는 것이다.
C. 쿼리 성능을 향상시키기 위해 데이터를 여러 서버로 분산시키는 것이다.
D. 각 데이터베이스에 대해 별도의 스토리지 엔진을 사용하는 것이다.
E. 모든 테이블을 하나로 합쳐서 데이터를 쉽게 관리할 수 있도록 하는 것이다.

-----------------------------------------

문제 9. 데이터베이스 데드락과 이를 방지하는 방법에 대해서 설명해보시오 (주관식)

-----------------------------------------

문제 10. 데이터베이스 데드락을 방지하기 위한 방법으로 옳지 않은 것은 무엇인가?

A. Wait-Die: 트랜잭션이 자원을 기다릴 때, 자원을 이미 요청한 트랜잭션이 더 높은 우선순위를 가진 경우 기다리며, 낮은 우선순위를 가진 경우 죽인다.
B. Wound-Wait: 자원을 기다리는 트랜잭션이 더 낮은 우선순위를 가진 경우 기다리고, 더 높은 우선순위를 가진 트랜잭션이 자원을 요청하면 자신이 해당 트랜잭션을 "죽여" 먼저 자원을 차지하게 한다.
C. Timeout: 일정 시간이 지난 후, 자원을 기다리던 트랜잭션이 일정 시간 이상 기다리면 자원을 포기하고 트랜잭션을 종료시킨다.
D. Wait-for Graph: 트랜잭션 간의 자원 요청 관계를 그래프 형태로 만들어서 순환(사이클)이 생기면 데드락이 발생했다고 판단하고 해당 트랜잭션을 종료시킨다.
E. 격리수준 변경: 트랜잭션의 격리수준을 변경하여 데드락을 방지하는 방법으로, 예를 들어 READ UNCOMMITTED로 변경하여 자원 잠금을 최소화할 수 있다.
